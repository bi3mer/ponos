import json
import sys
import os

if len(sys.argv) != 2:
    print("Error! Provide the path to the the graph file to read from")
    exit(1)

###############################
# Get code for custom node
# with open(os.path.join("assets", "customDataStructures.ts"), 'r') as f:
#     code = f.read()
code = ""

###############################
# Convert the graph to a MDP in GDM-TS
file_path = sys.argv[1]
if not os.path.exists(file_path):
    print("Error! Graph file provided does not exist!")
    exit(1)

with open(file_path, "r") as f:
    G = json.load(f)

id_to_edges = {}
id_to_lvl = {}
nodes = []

code += '/////////////////////////////////////////////\n'
code += '// Generated by exportGraphToGDM_TS.py\n'
code += 'import { Graph } from "./GDM-TS";\n'
code += 'import {CustomNode } from "./customNode";\n'
code += 'import {CustomEdge } from "./customEdge";\n'
code += 'import { KEY_DEATH, KEY_END, KEY_START } from "../core/constants";\n'

code += "\n// ========= Nodes =========\n"
code += "export const AUTO_MDP = new Graph();\n\n"

code += "AUTO_MDP.addNode(new CustomNode(KEY_START, 0, 0, false, [], [], -1));\n"
code += "AUTO_MDP.addNode(new CustomNode(KEY_DEATH, -1, 0, true, [], [], -1));\n"
# typescript += "MDP.addNode(new CustomNode(KEY_END, 1, 0, true, [],-1));\n\n"

# Get max reward
max_r = -1
for N in G['nodes']:
    max_r = max(max_r, N["reward"])

NUM_END_LEVELS = 1

for N in G['nodes']:
    if N["name"] == "start" or N["name"] == "death":
        continue

    if N["name"] == "end":
        # This is cheating but sue me
        N["levels"] = [[
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-------------",
            "-Xooooooooooo",
            "XXXXXXXXXXXXX",
        ]]

        # node = f'new CustomNode("end", 0, 0, true, [], {json.dumps(L)}, {N["depth"]})'
        # code += f"AUTO_MDP.addNode({node});\n"
        # continue

    # depth = id.split("-")[0]
    depth = 1 # TODO: set the depth
    is_terminal = "true" if N["name"] == 'end' else "false"

    name = N["name"]
    reward = -(max_r-N["reward"])/max_r
    depth = N["depth"]
    for i, L in enumerate(N["levels"]):
        node = f'new CustomNode("{name}-{i}", {reward}, 0, {is_terminal}, [], {json.dumps(L)}, {depth})'
        code += f"AUTO_MDP.addNode({node});\n"

code += "\n// ========= Edges =========\n"
for E in G['edges']:
    src = E["src"]
    tgt = E['tgt']

    if len(E['links']) > 0:
        for L in E['links']:
            src_name = f"{src}-{L['src-index']}"
            tgt_name = f"{tgt}-{L['tgt-index']}"
            link = json.dumps(L["link"])
            P = json.dumps([(tgt_name, 0.99), ("death", 0.01)])

            e = f'new CustomEdge("{src_name}", "{tgt_name}", {P}, {link})'
            code += f'AUTO_MDP.addEdge({e});\n'
    elif tgt == 'end':
        P = json.dumps([(tgt, 0.99), ("death", 0.01)])
        for N in G["nodes"]:
            if N["name"] == src:
                for i in range(len(N["levels"])):
                    src_name = f'{src}-{i}'
                    for j in range(NUM_END_LEVELS):
                        tgt_name = f"{tgt}-{j}"
                        P = json.dumps([(tgt_name, 0.99), ("death", 0.01)])
                        code += f'AUTO_MDP.addDefaultEdge("{src_name}", "{tgt_name}", {P});\n'
                break
    elif src == "start":
        for N in G["nodes"]:
            if N["name"] == tgt:
                for i in range(len(N["levels"])):
                    tgt_name = f"{tgt}-{i}"
                    P = json.dumps([(tgt_name, 0.99), ("death", 0.01)])
                    code += f'AUTO_MDP.addDefaultEdge("{src}", "{tgt_name}", {P});\n'
                break

PATH = os.path.join("autoMDP.ts")
with open(PATH, "w") as f:
    f.write(code)

print(f"Graph and levels written to: {PATH}")
