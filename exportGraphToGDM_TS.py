import json
import sys
import os

if len(sys.argv) != 2:
    print("Error! Provide the path to the the graph file to read from")
    exit(1)

###############################
# Get code for custom node
# with open(os.path.join("assets", "customDataStructures.ts"), 'r') as f:
#     code = f.read()
code = ""

###############################
# Convert the graph to a MDP in GDM-TS
file_path = sys.argv[1]
if not os.path.exists(file_path):
    print("Error! Graph file provided does not exist!")
    exit(1)

with open(file_path, "r") as f:
    G = json.load(f)

id_to_edges = {}
id_to_lvl = {}
nodes = []

code += '/////////////////////////////////////////////\n'
code += '// Generated by exportGraphToGDM_TS.py\n'
code += 'import { Graph } from "./GDM-TS";\n'
code += 'import {CustomNode } from "./customNode";\n'
code += 'import {CustomEdge } from "./customEdge";\n'
code += 'import { KEY_DEATH, KEY_END, KEY_START } from "../core/constants";\n'

code += "\n// ========= Nodes =========\n"
code += "export const AUTO_MDP = new Graph();\n\n"

code += "AUTO_MDP.addNode(new CustomNode(KEY_START, 0, 0, false, [], [], -1));\n"
code += "AUTO_MDP.addNode(new CustomNode(KEY_DEATH, -1, 0, true, [], [], -1));\n"
# typescript += "MDP.addNode(new CustomNode(KEY_END, 1, 0, true, [],-1));\n\n"

# Get max reward
max_r = -1
for N in G['nodes']:
    max_r = max(max_r, N["reward"])


for N in G['nodes']:
    if N["name"] == "start" or N["name"] == "death":
        continue

    if N["name"] == "end":
        # This is cheating but sue me
        N["levels"] = [[
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "------------",
            "oooooooooooo",
            "XXXXXXXXXXXX",
        ]]

    # depth = id.split("-")[0]
    depth = 1 # TODO: set the depth
    is_terminal = "true" if N["name"] == 'end' else "false"

    name = N["name"]
    reward = -(max_r-N["reward"])/max_r
    depth = N["depth"]
    for i, L in enumerate(N["levels"]):
        node = f'new CustomNode("{name}-{i}", {reward}, 0, {is_terminal}, [], {json.dumps(L)}, {depth})'
        code += f"AUTO_MDP.addNode({node});\n"

code += "\n// ========= Edges =========\n"
for E in G['edges']:
    src = E["src"]
    tgt = E['tgt']
    P = json.dumps(E["probability"])

    if len(E['links']) > 0:
        for L in E['links']:
            src_index = L["src-index"]
            tgt_index = L["tgt-index"]
            link = json.dumps(L["link"])

            e = f'new CustomEdge("{src}-{src_index}", "{tgt}-{tgt_index}", {P}, {link})'
            code += f'AUTO_MDP.addEdge({e});\n'
            # code += f'\tnew Link({L["src-index"]}, {L["tgt-index"]}, {json.dumps(L["link"])}),\n'
    elif tgt == 'end':
        for N in G["nodes"]:
            if N["name"] == src:
                for i in range(len(N["levels"])):
                    code += f'AUTO_MDP.addDefaultEdge("{src}-{i}", "{tgt}", {P});\n'
                break
    else:
      code += f'AUTO_MDP.addDefaultEdge("{src}", "{tgt}", {P});\n'

PATH = os.path.join("autoMDP.ts")
with open(PATH, "w") as f:
    f.write(code)

print(f"Graph and levels written to: {PATH}")
